// Generated by Scripts/embed_shaders.py

#pragma once

namespace TriEngine {
namespace ShaderSource {

constexpr const char* basicFrag = R"(#version 450 core
			
layout(location = 0) out vec4 FragColor;
layout(location = 1) out int ObjectID;

in vec2 v_TexCoord;
in vec4 v_Color;
in flat int v_TexIndex;
in flat int v_ObjectID;

uniform sampler2D u_Samplers[32];

void main()
{
	vec4 texColor;
	switch(int(v_TexIndex))
	{
		case  0: texColor = texture(u_Samplers[ 0], v_TexCoord); break;
		case  1: texColor = texture(u_Samplers[ 1], v_TexCoord); break;
		case  2: texColor = texture(u_Samplers[ 2], v_TexCoord); break;
		case  3: texColor = texture(u_Samplers[ 3], v_TexCoord); break;
		case  4: texColor = texture(u_Samplers[ 4], v_TexCoord); break;
		case  5: texColor = texture(u_Samplers[ 5], v_TexCoord); break;
		case  6: texColor = texture(u_Samplers[ 6], v_TexCoord); break;
		case  7: texColor = texture(u_Samplers[ 7], v_TexCoord); break;
		case  8: texColor = texture(u_Samplers[ 8], v_TexCoord); break;
		case  9: texColor = texture(u_Samplers[ 9], v_TexCoord); break;
		case 10: texColor = texture(u_Samplers[10], v_TexCoord); break;
		case 11: texColor = texture(u_Samplers[11], v_TexCoord); break;
		case 12: texColor = texture(u_Samplers[12], v_TexCoord); break;
		case 13: texColor = texture(u_Samplers[13], v_TexCoord); break;
		case 14: texColor = texture(u_Samplers[14], v_TexCoord); break;
		case 15: texColor = texture(u_Samplers[15], v_TexCoord); break;
		case 16: texColor = texture(u_Samplers[16], v_TexCoord); break;
		case 17: texColor = texture(u_Samplers[17], v_TexCoord); break;
		case 18: texColor = texture(u_Samplers[18], v_TexCoord); break;
		case 19: texColor = texture(u_Samplers[19], v_TexCoord); break;
		case 20: texColor = texture(u_Samplers[20], v_TexCoord); break;
		case 21: texColor = texture(u_Samplers[21], v_TexCoord); break;
		case 22: texColor = texture(u_Samplers[22], v_TexCoord); break;
		case 23: texColor = texture(u_Samplers[23], v_TexCoord); break;
		case 24: texColor = texture(u_Samplers[24], v_TexCoord); break;
		case 25: texColor = texture(u_Samplers[25], v_TexCoord); break;
		case 26: texColor = texture(u_Samplers[26], v_TexCoord); break;
		case 27: texColor = texture(u_Samplers[27], v_TexCoord); break;
		case 28: texColor = texture(u_Samplers[28], v_TexCoord); break;
		case 29: texColor = texture(u_Samplers[29], v_TexCoord); break;
		case 30: texColor = texture(u_Samplers[30], v_TexCoord); break;
		case 31: texColor = texture(u_Samplers[31], v_TexCoord); break;
	}

	if (texColor.a == 0.0) {
		discard;
	}

	FragColor = texColor * v_Color;

	ObjectID = v_ObjectID;
})";
constexpr const char* basicVert = R"(#version 450 core

layout(location = 0) in vec3 a_Position;
layout(location = 1) in vec4 a_Color;
layout(location = 2) in vec2 a_TexCoord;
layout(location = 3) in int a_TexIndex;
layout(location = 4) in int a_ObjectID;

uniform mat4 u_ViewProjection;

out vec2 v_TexCoord;
out vec4 v_Color;
out flat int v_TexIndex;
out flat int v_ObjectID;

void main()
{
	v_TexCoord = a_TexCoord;
	v_Color = a_Color;
	v_TexIndex = a_TexIndex;
	v_ObjectID = a_ObjectID;

	gl_Position = u_ViewProjection * vec4(a_Position, 1.0);	
})";
constexpr const char* particleFrag = R"(#version 450 core

layout(location = 0) in vec2 v_TexCoord;
layout(location = 1) in flat int v_TexIndex;
layout(location = 2) in vec4 v_Color;

layout(location = 2) uniform sampler2D u_Samplers[32];

layout(location = 0) out vec4 fragColor;

void main() {
	vec4 texColor;
	switch(int(v_TexIndex))
	{
		case  0: texColor = texture(u_Samplers[ 0], v_TexCoord); break;
		case  1: texColor = texture(u_Samplers[ 1], v_TexCoord); break;
		case  2: texColor = texture(u_Samplers[ 2], v_TexCoord); break;
		case  3: texColor = texture(u_Samplers[ 3], v_TexCoord); break;
		case  4: texColor = texture(u_Samplers[ 4], v_TexCoord); break;
		case  5: texColor = texture(u_Samplers[ 5], v_TexCoord); break;
		case  6: texColor = texture(u_Samplers[ 6], v_TexCoord); break;
		case  7: texColor = texture(u_Samplers[ 7], v_TexCoord); break;
		case  8: texColor = texture(u_Samplers[ 8], v_TexCoord); break;
		case  9: texColor = texture(u_Samplers[ 9], v_TexCoord); break;
		case 10: texColor = texture(u_Samplers[10], v_TexCoord); break;
		case 11: texColor = texture(u_Samplers[11], v_TexCoord); break;
		case 12: texColor = texture(u_Samplers[12], v_TexCoord); break;
		case 13: texColor = texture(u_Samplers[13], v_TexCoord); break;
		case 14: texColor = texture(u_Samplers[14], v_TexCoord); break;
		case 15: texColor = texture(u_Samplers[15], v_TexCoord); break;
		case 16: texColor = texture(u_Samplers[16], v_TexCoord); break;
		case 17: texColor = texture(u_Samplers[17], v_TexCoord); break;
		case 18: texColor = texture(u_Samplers[18], v_TexCoord); break;
		case 19: texColor = texture(u_Samplers[19], v_TexCoord); break;
		case 20: texColor = texture(u_Samplers[20], v_TexCoord); break;
		case 21: texColor = texture(u_Samplers[21], v_TexCoord); break;
		case 22: texColor = texture(u_Samplers[22], v_TexCoord); break;
		case 23: texColor = texture(u_Samplers[23], v_TexCoord); break;
		case 24: texColor = texture(u_Samplers[24], v_TexCoord); break;
		case 25: texColor = texture(u_Samplers[25], v_TexCoord); break;
		case 26: texColor = texture(u_Samplers[26], v_TexCoord); break;
		case 27: texColor = texture(u_Samplers[27], v_TexCoord); break;
		case 28: texColor = texture(u_Samplers[28], v_TexCoord); break;
		case 29: texColor = texture(u_Samplers[29], v_TexCoord); break;
		case 30: texColor = texture(u_Samplers[30], v_TexCoord); break;
		case 31: texColor = texture(u_Samplers[31], v_TexCoord); break;
	}
    fragColor = texColor * v_Color;

	if (fragColor.a == 0.0)
		discard;

})";
constexpr const char* particleVert = R"(#version 450 core

struct Particle {
	vec3 Position;
	vec2 Velocity;
	vec2 Acceleration;
	vec4 Color;
	float Lifetime;

	int TextureIndex;
};

layout(std430, binding = 0) readonly restrict buffer Particles {
    Particle particles[];
};

layout(location = 0) in vec2 a_Position;

layout(location = 0) uniform mat4 u_ViewProj;

layout(location = 0) out vec2 v_TexCoord;
layout(location = 1) out flat int v_TexIndex;
layout(location = 2) out vec4 v_Color;

void main() {
    int index = gl_InstanceID;

    Particle particle = particles[index];

	v_TexCoord = a_Position + 0.5;
	v_Color = particle.Color;
	v_TexIndex = particle.TextureIndex;

	vec3 globalPosition = vec3(a_Position.xy, 1.0) + particle.Position;

	gl_Position = u_ViewProj * vec4(globalPosition, 1.0);
})";
constexpr const char* particleSpawner = R"(#version 450 core

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct ParticleEmmiter {
	vec4 MinColor, MaxColor;
	vec3 MinOffset, MaxOffset;
	vec2 MinVelocity, MaxVelocity;
	vec2 MinAcceleration, MaxAcceleration;
	float MinLifetime, MaxLifetime;

	vec3 Position;

	float SpawnInterval, SpawnTimer;

	int TextureIndex;
};

struct Particle {
	vec3 Position;
	vec2 Velocity;
	vec2 Acceleration;
	vec4 Color;
	float Lifetime;

	int TextureIndex;
};

layout(std430, binding = 0) writeonly restrict buffer SSBO_0 {
  Particle particles[];
};

layout(std430, binding = 1) coherent restrict buffer SSBO_1 {
  int count;
  int indices[];
}freelist;

layout(location = 0) uniform int u_ParticlesToSpawn;
layout(location = 1) uniform int u_Seed;
layout(location = 2) uniform ParticleEmmiter u_Emitter;

uint hash(uint seed) {
    seed = (seed ^ 61u) ^ (seed >> 16u);
    seed *= 9u;
    seed = seed ^ (seed >> 4u);
    seed *= 0x27d4eb2du;
    seed = seed ^ (seed >> 15u);
    return seed;
}

float random(uint seed, float minVal, float maxVal) {
    float normalized = float(hash(seed)) / float(0xFFFFFFFFu);
    return mix(minVal, maxVal, normalized);
}

vec2 random2(uint seed, vec2 minVal, vec2 maxVal) {
    return vec2(random(seed, minVal.x, maxVal.x), 
                random(seed + 1u, minVal.y, maxVal.y));
}

vec3 random3(uint seed, vec3 minVal, vec3 maxVal) {
    return vec3(random(seed, minVal.x, maxVal.x), 
                random(seed + 1u, minVal.y, maxVal.y), 
                random(seed + 2u, minVal.z, maxVal.z));
}

vec4 random4(uint seed, vec4 minVal, vec4 maxVal) {
    return vec4(random(seed, minVal.x, maxVal.x), 
                random(seed + 1u, minVal.y, maxVal.y), 
                random(seed + 2u, minVal.z, maxVal.z), 
                random(seed + 3u, minVal.w, maxVal.w));
}


Particle CreateParticleAlt(uint seed) {
	Particle particle;
	particle.Position = u_Emitter.Position + random3(seed, u_Emitter.MinOffset, u_Emitter.MaxOffset);

	particle.Velocity = random2(seed, u_Emitter.MinVelocity, u_Emitter.MaxVelocity);
	particle.Acceleration = random2(seed, u_Emitter.MinAcceleration, u_Emitter.MaxAcceleration);
	particle.Color = random4(seed, u_Emitter.MinColor, u_Emitter.MaxColor);
	particle.Lifetime = random(seed, u_Emitter.MinLifetime, u_Emitter.MaxLifetime);
	particle.TextureIndex = u_Emitter.TextureIndex;

	return particle;
}


void main() {
	uint index = gl_GlobalInvocationID.x;

	if (index >= u_ParticlesToSpawn)
		return;

	int freeListIndex = atomicAdd(freelist.count, -1) - 1;
	if (freeListIndex < 0) {
		atomicAdd(freelist.count, 1);
		return;
	}

	int particleIndex = freelist.indices[freeListIndex];

	particles[particleIndex] = CreateParticleAlt(u_Seed+index);
	//CreateParticle(particles[particleIndex]);
})";
constexpr const char* particleUpdate = R"(#version 450 core

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct Particle {
	vec3 Position;
	vec2 Velocity;
	vec2 Acceleration;
	vec4 Color;
	float Lifetime;

	int TextureIndex;
};

layout(std430, binding = 0) buffer SSBO_0 {
  Particle particles[];
};

layout(std430, binding = 1) buffer SSBO_1 {
  coherent int count;
  int indices[];
}freelist;

layout(location = 0) uniform float u_DeltaTime;

void Update(inout Particle particle, int index) {
	if (particle.Lifetime > 0.0) {
		particle.Velocity += particle.Acceleration.xy * u_DeltaTime;
		particle.Position.xy += particle.Velocity.xy * u_DeltaTime;
		particle.Lifetime -= u_DeltaTime;

		if (particle.Lifetime <= 0.0) {
			particle.Color.a = 0.0;
			freelist.indices[atomicAdd(freelist.count, 1)] = index;
		}
	}
}

void main() {
	uint index = gl_GlobalInvocationID.x;

	if (index >= particles.length())
		return;

	Update(particles[index], int(index));
})";
constexpr const char* screenFrag = R"(#version 330 core
out vec4 FragColor;
  
in vec2 v_TexCoords;

uniform sampler2D u_ScreenSampler;

void main()
{ 
    FragColor = texture(u_ScreenSampler, v_TexCoords);
})";
constexpr const char* screenVert = R"(#version 330 core

layout (location = 0) in vec3 a_Position;
layout (location = 1) in vec2 a_TexCoords;

out vec2 v_TexCoords;

void main()
{
    v_TexCoords = a_TexCoords;

    gl_Position = vec4(a_Position, 1.0); 
}  )";
constexpr const char* lineFrag = R"(#version 330 core

in vec4 fragColor;
out vec4 outColor;

void main() {
    outColor = fragColor;
}
)";
constexpr const char* lineVert = R"(#version 330 core

layout(location = 0) in vec3 a_Pos;
layout(location = 1) in vec4 a_Color;

uniform mat4 u_ViewProjection;

out vec4 fragColor;

void main() {
    fragColor = a_Color;
    gl_Position = u_ViewProjection * vec4(a_Pos, 1.0);
}
)";
} }
